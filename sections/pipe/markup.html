<section id="section-pipe" class="clearfix" ng-controller="pipeCtrl">
	<h2 class="h2">pipe/ajax plugin</h2>
	<p>
		This might be the most powerful plugin. When a directive calls the table controller api (sortBy, search, slice, ...) a variable representing the internal
		table state is updated and a <em>pipe</em> function is called. By default it basically pipes the filter, sort and slice(pagination) operations on the bound array.
		But with this directive you can overwrite the default pipe function which can be handy to call your server. The function takes as arguments, the object which represents
		the table state, and a reference to the table controller.
	</p>
	<p class="bg-info padding text-justify">
		Note that if you want the pagination directive to update, you must set in your pipe function, the total number of pages as smart-table has no clue about your dataset and this information has to come
		from your server.
	</p>
	<tabset><tab heading="markup">
<pre ng-non-bindable><code class="language-markup">
&lt;table class="table" st-pipe="mc.callServer" st-table="mc.displayed">
	&lt;thead>
	&lt;tr>
		&lt;th st-sort="id">id&lt;/th>
		&lt;th st-sort="name">name&lt;/th>
		&lt;th st-sort="age">age&lt;/th>
		&lt;th st-sort="saved">saved people&lt;/th>
	&lt;/tr>
	&lt;tr>
		&lt;th>&lt;input st-search="id"/>&lt;/th>
		&lt;th>&lt;input st-search="name"/>&lt;/th>
		&lt;th>&lt;input st-search="age"/>&lt;/th>
		&lt;th>&lt;input st-search="saved"/>&lt;/th>
	&lt;/tr>
	&lt;/thead>
	&lt;tbody ng-show="!mc.isLoading">
	&lt;tr ng-repeat="row in mc.displayed">
		&lt;td>{{row.id}}&lt;/td>
		&lt;td>{{row.name}}&lt;/td>
		&lt;td>{{row.age}}&lt;/td>
		&lt;td>{{row.saved}}&lt;/td>
	&lt;/tr>
	&lt;/tbody>
	&lt;tbody ng-show="mc.isLoading">
	&lt;tr>
		&lt;td colspan="4" class="text-center">Loading ... &lt;/td>
	&lt;/tr>
	&lt;/tbody>
	&lt;tfoot>
	&lt;tr>
		&lt;td class="text-center" st-pagination="" st-items-by-page="10" colspan="4">
		&lt;/td>
	&lt;/tr>
	&lt;/tfoot>
&lt;/table>	
</code></pre>
	</tab>
		<tab heading="Controller">
<pre><code class="language-javascript">app.controller('pipeCtrl', ['Resource', function (service) {

  var ctrl = this;

  this.displayed = [];

  this.callServer = function callServer(tableState) {

    ctrl.isLoading = true;

    var pagination = tableState.pagination;

    var start = pagination.start || 0;     // This is NOT the page number, but the index of item in the list that you want to use to display the table.
    var number = pagination.number || 10;  // Number of entries showed per page.

    service.getPage(start, number, tableState).then(function (result) {
      ctrl.displayed = result.data;
      tableState.pagination.numberOfPages = result.numberOfPages;//set the number of pages so the pagination can update
      ctrl.isLoading = false;
    });
  };

}])
</code></pre>
		</tab>
		<tab heading="Service">
			<pre><code class="language-javascript">
	app.factory('Resource', ['$q', '$filter', '$timeout', function ($q, $filter, $timeout) {

	//this would be the service to call your server, a standard bridge between your model an $http

	// the database (normally on your server)
	var randomsItems = [];

	function createRandomItem(id) {
		var heroes = ['Batman', 'Superman', 'Robin', 'Thor', 'Hulk', 'Niki Larson', 'Stark', 'Bob Leponge'];
		return {
			id: id,
			name: heroes[Math.floor(Math.random() * 7)],
			age: Math.floor(Math.random() * 1000),
			saved: Math.floor(Math.random() * 10000)
		};

	}

	for (var i = 0; i < 1000; i++) {
		randomsItems.push(createRandomItem(i));
	}


	//fake call to the server, normally this service would serialize table state to send it to the server (with query parameters for example) and parse the response
	//in our case, it actually performs the logic which would happened in the server
	function getPage(start, number, params) {

		var deferred = $q.defer();

		var filtered = params.search.predicateObject ? $filter('filter')(randomsItems, params.search.predicateObject) : randomsItems;

		if (params.sort.predicate) {
			filtered = $filter('orderBy')(filtered, params.sort.predicate, params.sort.reverse);
		}

		var result = filtered.slice(start, start + number);

		$timeout(function () {
			//note, the server passes the information about the data set size
			deferred.resolve({
				data: result,
				numberOfPages: Math.ceil(1000 / number)
			});
		}, 1500);


		return deferred.promise;
	}

	return {
		getPage: getPage
	};

}]);</code></pre>
		</tab>
	</tabset>
	<div class="table-container" ng-controller="pipeCtrl as mc">
		<table class="table" st-pipe="mc.callServer" st-table="mc.displayed">
			<thead>
			<tr>
				<th st-sort="id">id</th>
				<th st-sort="name">name</th>
				<th st-sort="age">age</th>
				<th st-sort="saved">saved people</th>
			</tr>
			<tr>
				<th><input st-search="id"/></th>
				<th><input st-search="name"/></th>
				<th><input st-search="age"/></th>
				<th><input st-search="saved"/></th>
			</tr>
			</thead>
			<tbody ng-show="!mc.isLoading">
			<tr ng-repeat="row in mc.displayed">
				<td>{{row.id}}</td>
				<td>{{row.name}}</td>
				<td>{{row.age}}</td>
				<td>{{row.saved}}</td>
			</tr>
			</tbody>
			<tbody ng-show="mc.isLoading">
			<tr>
				<td colspan="4" class="text-center"><div class="loading-indicator"></div>
				</td>
			</tr>
			</tbody>
			<tfoot>
			<tr>
				<td class="text-center" st-pagination="" st-items-by-page="10" colspan="4">
				</td>
			</tr>
			</tfoot>
		</table>
	</div>
	<p>Wow impressive, we just have plugged our table with a server. Of course in our example the data is random and not consistent with the event which triggered the request, but in reallity the server would sort, filter, slice according to the query</p>
	<div class="text-center">
		<a class="btn btn-primary" href="https://github.com/lorenzofox3/smart-table-website/tree/gh-pages/sections/pipe"><i class="glyphicon glyphicon-pencil"></i> improve the documentation</a>
	</div>
</section>
